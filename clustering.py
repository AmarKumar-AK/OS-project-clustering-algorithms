#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 4.26
#  in conjunction with Tcl version 8.6
#    Nov 23, 2019 01:36:41 AM IST  platform: Linux

import sys
import math; #For pow and sqrt
import sys;
import time
# import matplotlib.pyplot as a
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg,NavigationToolbar2Tk
from matplotlib.figure import Figure
from random import shuffle, uniform;
import threading as th
sem = th.Semaphore(1)
from functools import partial
try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True
####mean shift
import numpy as np

fig = Figure(figsize=(10,8))
#fig.set_size_inches(13, 9.5)
a = fig.add_subplot(1,1,1)
fig.tight_layout()
ret=[[0]*2]*3
color=["red","blue","green"]
lines=[]
centroid=[]
datapoints=[]
# v= IntVar()
# v.set(1)
width=0
height=0
# anima_time=0
#import firoz_support


############
no_th=5
# look_distance=3   #0.8
# kernel_bandwidth=2
# no_iter=6
circles=[]
ind=0
##########

######
# ret1=[]

def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    # firoz_support.set_Tk_var()
    root.resizable(True,True)
    top = Toplevel1 (root)
    #firoz_support.init(root, top)
    root.mainloop()

w = None
def create_Toplevel1(root, *args, **kwargs):
    '''Starting point when module is imported by another program.'''
    global w, w_win, rt
    rt = root
    w = tk.Toplevel (root)
    #firoz_support.set_Tk_var()
    top = Toplevel1 (w)
    # firoz_support.init(w, top, *args, **kwargs)
    return (w, top)

def destroy_Toplevel1():
    global w
    w.destroy()
    w = None


def ReadData(fileName):
    #Read the file, splitting by lines
    f = open(fileName,'r');
    liness = f.read().splitlines();
    f.close();

    items = [];

    for i in range(1,len(liness)):
        line = liness[i].split(',');
        itemFeatures = [];

        for j in range(len(line)-1):
            v = float(line[j]); #Convert feature value to float
            itemFeatures.append(v); #Add feature value to dict

        items.append(itemFeatures);

    shuffle(items);

    return items;


###_Auxiliary Function_###time
def FindColMinMax(items):
    n = len(items[0]);
    minima = [sys.maxsize for i in range(n)];
    maxima = [-sys.maxsize -1 for i in range(n)];

    for item in items:
        for f in range(len(item)):
            if(item[f] < minima[f]):
                minima[f] = item[f];

            if(item[f] > maxima[f]):
                maxima[f] = item[f];

    return minima,maxima;

def EuclideanDistance(x,y):
    S = 0; #The sum of the squared differences of the elements
    for i in range(len(x)):
        S += math.pow(x[i]-y[i],2);
    ret=math.sqrt(S)
    #print("euuci"+str(ret))

    return ret; #The square root of the sum

def InitializeMeans(items,k,cMin,cMax,Canvas12):
    #Initialize means to random numbers between
    #the min and max of each column/feature

    f = len(items[0]); #number of features
    means = [[0 for i in range(f)] for j in range(k)];

    j=0;
    for mean in means:
        for i in range(len(mean)):
            #Set value to a random float
            #(adding +-1 to avoid a wide placement of a mean)
            mean[i] = uniform(cMin[i]+1,cMax[i]-1);
        #a.clear()
        centroid.append(a.scatter(mean[0],mean[1],c=color[j],alpha=0.5,s=50,marker="D"))
        Canvas12.draw()
        time.sleep(anima_time)
        #a.pause(0.1)
        j=j+1
    #a.show();
    return means;

def UpdateMean(n,mean,item):
    for i in range(len(mean)):
        m = mean[i];
        m = (m*(n-1)+item[i])/float(n);
        mean[i] = round(m,3);

    return mean;

def FindClusters(means,items,Canvas12):
    clusters = [[] for i in range(len(means))]; #Init clusters

    for item in items:
        #Classify item into a cluster
        index = Classify(means,item);
        # print("means "+str(means[index]))
        # print("item "+str(item))
        x=[means[index][0],item[0]]
        y=[means[index][1],item[1]]
        #a.clear()
        a.scatter(item[0],item[1],c=color[index],alpha=0.5,s=10);
        Canvas12.draw()
        time.sleep(anima_time)
        #a.pause(0.1)
        #a.clear()
        lines.append(a.plot(x, y, linewidth=0.5,c=color[index],gid=1)[0])
        Canvas12.draw()
        time.sleep(anima_time)
        #a.pause(0.1)
        #print("firoz")
        #Add item to cluster
        clusters[index].append(item);

    return clusters;


###_Core Functions_###
def Classify(means,item):
    #Classify item to the mean with minimum distance

    minimum = sys.maxsize;
    index = -1;

    for i in range(len(means)):
        #Find distance from item to mean
        dis = EuclideanDistance(item,means[i]);
        if(dis < minimum):
            minimum = dis;
            index = i;

    return index;

def RecomputeCC(cluster,mean,i):
    mean_c=[0]*2
    for item in cluster:
        mean_c[0]=mean_c[0]+item[0]
        mean_c[1]=mean_c[1]+item[1]
    if(len(cluster)!=0):
        mean_c[0]=mean_c[0]/len(cluster)
        mean_c[1]=mean_c[1]/len(cluster)
    #return mean_c
    ret[i]=mean_c


def CalculateMeans(k,items,Canvas12,maxIterations=10):
    #Find the minima and maxima for columns
    cMin, cMax = FindColMinMax(items);
    #Initialize means at random points
    means = InitializeMeans(items,k,cMin,cMax,Canvas12);
    #print(means)
    #Calculate means
    for e in range(maxIterations):
        #If no change of cluster occurs, halt
        noChange = True;
        clusters = FindClusters(means,items,Canvas12);
        #print(clusters)
        t=[0]*k
        # print(lines)
        for line in lines:
            #print(line)
            line.remove()
            #a.pause(0.1)
        lines.clear()
        for c in centroid:
            c.remove()
            #a.pause(0.1)
        centroid.clear()
        for i in range(len(means)):
            t[i]=th.Thread(target=RecomputeCC , args=(clusters[i],means[i],i,))
            #print("tid = "+str(t[i]))
            t[i].start()
        means_cth=[0]*k
        for i in range(len(means)):
            t[i].join()
            #a.clear()
            centroid.append(a.scatter(ret[i][0],ret[i][1],c=color[i],alpha=0.5,s=50,marker="D"))
            Canvas12.draw()
            print("fffffffffffffffffffffffffff  ",anima_time)
            time.sleep(anima_time)
            #print(centroid)
            #a.pause(0.1)
            #print("means + "+str(ret[i]))
            if(means[i] != ret[i]):
                noChange = False


        #Nothing changed, return
        if(noChange):
            print("completedddddddddddddddddddddddddddd")
            break;
        for i in range(len(means)):
            means[i] = ret[i]
    FindClusters(means,items,Canvas12)
    return means;

def CutToTwoFeatures(items,indexA,indexB):
    n = len(items);
    X = [];
    for i in range(n):
        item = items[i];
        newItem = [item[indexA],item[indexB]];
        X.append(newItem);

    return X;

##############################################   Mean shift
def ReadData_m(fileName):
    #Read the file, splitting by lines
    f = open(fileName,'r');
    liness = f.read().splitlines();
    f.close();

    items = [];

    for i in range(0,len(liness)):
        line = liness[i].split(',');
        itemFeatures = [];

        for j in range(len(line)):
            v = float(line[j]); #Convert feature value to float
            itemFeatures.append(v); #Add feature value to dict

        items.append(itemFeatures);

    shuffle(items);
    return items;

def euclid_distance(x,y):
    S = 0; #The sum of the squared differences of the elements
    for i in range(len(x)):
        S += math.pow(x[i]-y[i],2);
    ret=math.sqrt(S)
    #print("euuci"+str(ret))
    return ret; #The square root of the sum

def neighbourhood_points(X, x_centroid, distance):
    eligible_X = []
    for x in X:
        distance_between = euclid_distance(x, x_centroid)
        # print('Evaluating: [%s vs %s] yield dist=%.2f' % (x, x_centroid, distance_between))
        if distance_between <= distance:
            eligible_X.append(x)
    return eligible_X

def gaussian_kernel(distance):
    val = (1/(bandwidth*math.sqrt(2*math.pi))) * np.exp(-0.5*((distance / bandwidth))**2)
    return val

def runner(X,x,i):
    ### Step 1. For each datapoint x E X, find the neighbouring points N(x) of x.
    neighbours = neighbourhood_points(X, x, look_distance)

    ### Step 2. For each datapoint x E X, calculate the mean shift m(x).
    numerator = [0,0]
    denominator = 0
    for neighbour in neighbours:
        distance = euclid_distance(neighbour, x)
        weight = gaussian_kernel(distance)
        numerator[0] += (weight * neighbour[0])
        numerator[1] += (weight * neighbour[1])
        denominator += weight

    new_x=[0,0]
    new_x[0] = numerator[0] / denominator
    new_x[1] = numerator[1] / denominator

        ### Step 3. For each datapoint x E X, update x <- m(x).
    X[i] = new_x

    print(new_x)

def meanShift(original_X,Canvas12):

    X = np.copy(original_X)
    past_X = [[0,0]]*len(X)
    print("l = "+str(len(X)))
    already_joined=[]
    for it in range(no_iter):
        t=[0]*len(X)

        for i in range(0,len(X)):       #for i, x in enumerate(X):

            #for j in range(no_th):
            print("i = "+str(i))
                # print("i+j = "+str(i+j))
                # print("Xi+j = "+str(X[i+j]))

            t[i]=th.Thread(target=runner , args=(X,X[i],i,))
            t[i].start()
            if(past_X[i][0]==X[i][0] and past_X[i][1]==X[i][1]):
                t[i].join()
                    # plt.scatter(X[i+j][0],X[i+j][1],c="red",alpha=0.5,s=50,marker="D")
                circle=matplotlib.patches.Circle((X[i][0],X[i][1]),radius=look_distance,fill=False,color='b')
                # plt.gcf().gca().add_artist(circle)
                a.add_artist(circle)
                circles.append(circle)
                Canvas12.draw()
                # plt.pause(0.0001)
                time.sleep(anima_time_m)
                already_joined.append(i)
                #time.sleep(5)
                #t[j].join()
        for i in range(len(X)):
            if (i not in already_joined):
                t[i].join()
                # plt.scatter(X[i+j][0],X[i+j][1],c="red",alpha=0.5,s=50,marker="D")
                circle=matplotlib.patches.Circle((X[i][0],X[i][1]),radius=look_distance,fill=False,color='b')
                # plt.gcf().gca().add_artist(circle)
                a.add_artist(circle)
                Canvas12.draw()
                circles.append(circle)
                # plt.pause(0.0001)
                time.sleep(anima_time_m)

        for c in circles:
            c.remove()
            # plt.pause(0.0001)
            time.sleep(anima_time_m)
        circles.clear()

        past_X=np.copy(X)
    unique=[]
    color=["red","blue","green","purple","yellow","orange","pink","cyan","black","magenta"]
    for i in range(len(X)):
        flag=0
        for j in range(len(unique)):
            if(euclid_distance(X[i],unique[j]) < 0.1 ):
                flag=1
                break
        if(flag==0):
            unique.append(X[i])
    # print("aaaaaaaaaaaaaaaaaa")
    print(unique)
    # print("999999999999 = ",original_X)
    for i in range(len(X)):
        for j in range(len(unique)):
            if(euclid_distance(X[i],unique[j]) < 0.1):
                ind=j
                # print("dsvvvvvvvvvvvvvvvvvvvv")
        a.scatter(original_X[i][0],original_X[i][1],c=color[ind],alpha=0.5,s=10)
        Canvas12.draw()
        # plt.pause(0.0001)
        time.sleep(anima_time_m)
################################################ Hierarchical

def ReadData_h(fileName):
    #Read the file, splitting by lines
    f = open(fileName,'r');
    liness = f.read().splitlines();
    f.close();

    items = [];

    for i in range(0,len(liness)):
        line = liness[i].split(',');
        itemFeatures = [];

        for j in range(len(line)-1):
            v = float(line[j]); #Convert feature value to float
            itemFeatures.append(v); #Add feature value to dict

        items.append(itemFeatures);

    # shuffle(items);

    return items;

def distance(thno,a,b):
    x=float(a[0])-float(b[0])
    x=x*x
    y=float(a[1])-float(b[1])
    y=y*y
    dist=round(math.sqrt(x+y),2)
    ret1[thno]=dist

def distance_p(a,b):
    x=float(a[0])-float(b[0])
    x=x*x
    y=float(a[1])-float(b[1])
    y=y*y
    dist=round(math.sqrt(x+y),2)
    return dist

def minimum(matrix):
    p=[0,0]
    mn=1000
    for i in range(0,len(matrix)):
        for j in range(0,len(matrix[i])):
            if (matrix[i][j]>0 and matrix[i][j]<mn):
                mn=matrix[i][j]
                p[0]=i
                p[1]=j
    return p

def newpoint(pt):
    x=float(pt[0][0])+float(pt[1][0])
    x=x/2
    y=float(pt[0][1])+float(pt[1][1])
    y=y/2
    midpoint=[x,y]
    return midpoint


################################################

class Toplevel1:
    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = 'RoyalBlue1'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85'
        _ana2color = '#ececec' # Closest X11 color: 'gray92'
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.',background=_bgcolor)
        self.style.configure('.',foreground=_fgcolor)
        self.style.configure('.',font="TkDefaultFont")
        self.style.map('.',background=
            [('selected', _compcolor), ('active',_ana2color)])

        width1 = root.winfo_screenwidth()
        height1 = root.winfo_screenheight()
        top.geometry("{0}x{1}+0+0".format(root.winfo_screenwidth(),root.winfo_screenheight()))
        top.minsize(1, 1)
        top.maxsize(width, height)
        top.resizable(1, 1)
        top.title("OS Project")
        top.configure(highlightcolor="black")
        top.configure(background="RoyalBlue2")

        width1 = root.winfo_screenwidth()
        height1 = root.winfo_screenheight()
        padding=20
        self.Frame1 = tk.Frame(top)
        self.Frame1.place(x=padding, y=padding, height=  height1 -(5*padding)      # x  1.187  y 1.615
                , width= width1-(5*padding))
        # self.Frame1.place(relx=0.023, rely=0.028, relheight=0.919
        #         , relwidth=0.968)
        self.Frame1.configure(relief='ridge')
        self.Frame1.configure(borderwidth="2")
        self.Frame1.configure(relief="ridge")
        self.Frame1.configure(cursor="fleur")
        self.Frame1.configure(background="light blue")

        self.Label1 = tk.Label(self.Frame1)
        self.Label1.place(relx=0.348, rely=0.031, height=25, width=400)
        self.Label1.configure(activebackground="#f9f9f9")
        self.Label1.configure(font="-family {Times} -size 18")
        self.Label1.configure(text='''Multithreaded Clustering Package''')

        self.TSeparator1 = ttk.Separator(self.Frame1)
        self.TSeparator1.place(relx=0.161, rely=0.098, relheight=0.916)
        self.TSeparator1.configure(orient="vertical")

        self.TSeparator2 = ttk.Separator(self.Frame1)
        self.TSeparator2.place(relx=-0.005, rely=0.098, relwidth=1.067)

        self.Canvas1 = tk.Canvas(self.Frame1)
        self.Canvas1.place(relx=0.188, rely=0.122, relheight=0.856
                , relwidth=0.78)
        self.Canvas1.configure(borderwidth="2")
        self.Canvas1.configure(cursor="fleur")
        self.Canvas1.configure(relief="ridge")
        self.Canvas1.configure(selectbackground="#c4c4c4")

        self.Label4 = tk.Label(self.Canvas1)
        self.Label4.place(relx=-0.173, rely=0.606, height=15, width=39)
        self.Label4.configure(text='''Label''')

        self.TSeparator3 = ttk.Separator(self.Frame1)
        self.TSeparator3.place(relx=0.003, rely=0.434, relwidth=0.158)

        self.Label2 = tk.Label(self.Frame1)
        self.Label2.place(relx=0.008, rely=0.521, height=15, width=130)
        self.Label2.configure(text='''Animation Speed :''')

        self.Spinbox1 = tk.Spinbox(self.Frame1, from_=0.00, to=100.00)
        self.Spinbox1.place(relx=0.111, rely=0.519, relheight=0.026
                , relwidth=0.037)
        self.Spinbox1.configure(activebackground="#f9f9f9")
        self.Spinbox1.configure(background="white")
        self.Spinbox1.configure(font="TkDefaultFont")
        self.Spinbox1.configure(highlightbackground="black")
        self.Spinbox1.configure(increment="0.01")
        self.Spinbox1.configure(justify='center')
        self.Spinbox1.configure(relief="raised")
        self.Spinbox1.configure(selectbackground="#c4c4c4")
        # self.Spinbox1.configure(format=%0.02.0.f)
        #self.Spinbox1.configure(textvariable=firoz_support.spinbox)
        # self.value_list = [0.00,]
        # self.Spinbox1.configure(values=self.value_list)

        self.Label3 = tk.Label(self.Frame1)
        self.Label3.place(relx=0.016, rely=0.618, height=15, width=99)
        #self.Label3.configure(text='''Label''')

        self.Label5 = tk.Label(self.Frame1)
        self.Label5.place(relx=0.016, rely=0.715, height=15, width=99)
        #self.Label5.configure(text='''Label''')

        self.Label6 = tk.Label(self.Frame1)
        self.Label6.place(relx=0.015, rely=0.811, height=15, width=99)
        #self.Label6.configure(text='''Label''')

        self.Spinbox2 = tk.Spinbox(self.Frame1, from_=0.0, to=100.0)
        self.Spinbox2.place(relx=0.111, rely=0.614, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2.configure(activebackground="#f9f9f9")
        self.Spinbox2.configure(background="white")
        self.Spinbox2.configure(font="TkDefaultFont")
        self.Spinbox2.configure(highlightbackground="black")
        self.Spinbox2.configure(increment="1")
        self.Spinbox2.configure(justify='center')
        self.Spinbox2.configure(relief="raised")
        self.Spinbox2.configure(selectbackground="#c4c4c4")
        #self.Spinbox2.configure(textvariable=firoz_support.spinbox)

        self.Spinbox2_1 = tk.Spinbox(self.Frame1, from_=0.0, to=100.0)
        self.Spinbox2_1.place(relx=0.111, rely=0.713, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_1.configure(activebackground="#f9f9f9")
        self.Spinbox2_1.configure(background="white")
        self.Spinbox2_1.configure(font="TkDefaultFont")
        self.Spinbox2_1.configure(highlightbackground="black")
        self.Spinbox2_1.configure(increment="0.1")
        self.Spinbox2_1.configure(justify='center')
        self.Spinbox2_1.configure(relief="raised")
        self.Spinbox2_1.configure(selectbackground="#c4c4c4")
        #self.Spinbox2_1.configure(textvariable=firoz_support.spinbox)

        self.Spinbox2_2 = tk.Spinbox(self.Frame1, from_=0.0, to=100.0)
        self.Spinbox2_2.place(relx=0.111, rely=0.808, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_2.configure(activebackground="#f9f9f9")
        self.Spinbox2_2.configure(background="white")
        self.Spinbox2_2.configure(font="TkDefaultFont")
        self.Spinbox2_2.configure(highlightbackground="black")
        self.Spinbox2_2.configure(increment="0.1")
        self.Spinbox2_2.configure(justify='center')
        self.Spinbox2_2.configure(relief="raised")
        self.Spinbox2_2.configure(selectbackground="#c4c4c4")
        #self.Spinbox2_2.configure(textvariable=firoz_support.spinbox)
        # print("v=",v)
        self.Radiobutton1 = tk.Radiobutton(self.Frame1)
        self.Radiobutton1.place(relx=0.005, rely=0.153, relheight=0.026
                , relwidth=0.126)
        self.Radiobutton1.configure(cursor="fleur")
        self.Radiobutton1.configure(justify='left')
        self.Radiobutton1.configure(text='''K-Means Clustering''')
        self.Radiobutton1.configure(value="1")
        self.Radiobutton1.config(state='normal')
        #self.Radiobutton1.configure(variable=firoz_support.selectedButton)
        # self.Radiobutton1.config(variable=v)

        self.Radiobutton2 = tk.Radiobutton(self.Frame1)
        self.Radiobutton2.place(relx=0.002, rely=0.244, relheight=0.026
                , relwidth=0.142)
        self.Radiobutton2.configure(justify='left')
        self.Radiobutton2.configure(text='''MeanShift Clustering''')
        self.Radiobutton2.configure(value="2")
        self.Radiobutton2.config(state='normal')
        #self.Radiobutton2.configure(variable=firoz_support.selectedButton)
        # self.Radiobutton2.config(variable=v)

        self.Radiobutton2_3 = tk.Radiobutton(self.Frame1)
        self.Radiobutton2_3.place(relx=0.011, rely=0.336, relheight=0.026
                , relwidth=0.142)
        self.Radiobutton2_3.configure(activebackground="#f9f9f9")
        self.Radiobutton2_3.configure(justify='left')
        self.Radiobutton2_3.configure(text='''Hierarchical Clustering''')
        self.Radiobutton2_3.configure(value="3")
        self.Radiobutton2_3.config(state='normal')
        #self.Radiobutton2_3.configure(variable=firoz_support.selectedButton)
        # print("v=",v)
        # self.Radiobutton2_3.config(variable=v)

        self.Button1 = tk.Button(self.Frame1)
        self.Button1.place(relx=0.047, rely=0.916, height=25, width=70)
        self.Button1.configure(text='''Start''')
        self.Button1.configure(background="green2")
        ww=self.Canvas1.winfo_width()
        hh=self.Canvas1.winfo_height()


        Canvas12 = FigureCanvasTkAgg(fig,master=self.Canvas1)
        Canvas12.draw()
        Canvas12.get_tk_widget().pack(side = tk.LEFT, fill = tk.BOTH)

        self.Radiobutton1.bind('<Button-1>',partial(self.kmean_p,Canvas12=Canvas12))
        self.Radiobutton2.bind('<Button-1>',partial(self.mean_p,Canvas12=Canvas12))
        self.Radiobutton2_3.bind('<Button-1>',partial(self.hier_p,Canvas12=Canvas12))

    @staticmethod
    def popup1(event, *args, **kwargs):
        Popupmenu1 = tk.Menu(root, tearoff=0)
        Popupmenu1.configure(activebackground="#f9f9f9")
        Popupmenu1.post(event.x_root, event.y_root)

    @staticmethod
    def popup2(event, *args, **kwargs):
        Popupmenu2 = tk.Menu(root, tearoff=0)
        Popupmenu2.configure(activebackground="#f9f9f9")
        Popupmenu2.post(event.x_root, event.y_root)

    def kmean_p(self,e,Canvas12):
        print("1 = ",self.Radiobutton1['state'])
        self.Label3.place(relx=0.016, rely=0.618, height=15, width=99)
        self.Label3.configure(text='''Label''')
        self.Label5.place(relx=0.016, rely=0.715, height=15, width=99)
        self.Label5.configure(text='''Label''')
        self.Label6.place(relx=0.015, rely=0.811, height=15, width=99)
        self.Label6.configure(text='''Label''')

        self.Spinbox2.place(relx=0.111, rely=0.614, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_1.place(relx=0.111, rely=0.713, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_2.place(relx=0.111, rely=0.808, relheight=0.026
                , relwidth=0.037)

        if(self.Radiobutton1['state']!='disabled'):
            # print("1 = ",self.Radiobutton1['state'])
            self.Label3['text']='K'
            self.Label5['text']='Max Iter'
            self.Label6.place_forget()
            # self.Label6.place(in_=self.Frame1)
            self.Spinbox2_2.place_forget()
            # self.Spinbox2_2.place(in_=self.Frame1)

        self.Button1.bind('<Button-1>',partial(self.kmean,Canvas12=Canvas12))


    def kmean(self,e,Canvas12):
        k=self.Spinbox2.get()
        anima_timee=self.Spinbox1.get()
        global anima_time
        anima_time=float(anima_timee)
        k=int(k)
        print("kx  = ",k,anima_time)
        root.update()
        print("hello tk")
        items = ReadData('data.txt');
        items = CutToTwoFeatures(items,2,3);
        #print(items)
        a.clear()
        for item in items:
            #a.clear()
            a.scatter(item[0],item[1],c="gray",alpha=0.5,s=10)
            Canvas12.draw()
            time.sleep(anima_time)
            #a.pause(0.1)
        # k = 3;
        means = CalculateMeans(k,items,Canvas12);
        print (means);
        root.update()

################################################### Mean Shift

    def mean_p(self,e,Canvas12):
        print("1 = ",self.Radiobutton1['state'])
        self.Label3.place(relx=0.016, rely=0.618, height=15, width=99)
        self.Label3.configure(text='''Label''')
        self.Label5.place(relx=0.016, rely=0.715, height=15, width=99)
        self.Label5.configure(text='''Label''')
        self.Label6.place(relx=0.015, rely=0.811, height=15, width=99)
        self.Label6.configure(text='''Label''')

        self.Spinbox2.place(relx=0.111, rely=0.614, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_1.place(relx=0.111, rely=0.713, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_2.place(relx=0.111, rely=0.808, relheight=0.026
                , relwidth=0.037)

        if(self.Radiobutton1['state']!='disabled'):
            # print("1 = ",self.Radiobutton1['state'])
            self.Label3['text']='Bandwidth'
            self.Label5['text']='Look_distance'
            self.Label6['text']='no_itr'

        self.Button1.bind('<Button-1>',partial(self.mean,Canvas12=Canvas12))

    def mean(self,e,Canvas12):
        items = ReadData_m('data1.txt')
        items = CutToTwoFeatures(items,0,1)
        bndth=self.Spinbox2.get()
        global bandwidth
        bandwidth=float(bndth)
        lkd=self.Spinbox2_1.get()
        global look_distance
        look_distance=float(lkd)
        notr=self.Spinbox2_2.get()
        global no_iter
        no_iter=int(notr)
        anmt=self.Spinbox1.get()
        global anima_time_m
        anima_time_m=float(anmt)
        print(items)
        a.clear()
        for item in items:
            a.scatter(item[0],item[1],c="gray",alpha=0.5,s=10)
            # plt.pause(0.00001)
            Canvas12.draw()
            time.sleep(0.01)

        meanShift(items,Canvas12)
        # plt.show();

#################################### Hierarchical
    def hier_p(self,e,Canvas12):
        print("1 = ",self.Radiobutton1['state'])
        self.Label3.place(relx=0.016, rely=0.618, height=15, width=99)
        self.Label3.configure(text='''Label''')
        self.Label5.place(relx=0.016, rely=0.715, height=15, width=99)
        self.Label5.configure(text='''Label''')
        self.Label6.place(relx=0.015, rely=0.811, height=15, width=99)
        self.Label6.configure(text='''Label''')

        self.Spinbox2.place(relx=0.111, rely=0.614, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_1.place(relx=0.111, rely=0.713, relheight=0.026
                , relwidth=0.037)
        self.Spinbox2_2.place(relx=0.111, rely=0.808, relheight=0.026
                , relwidth=0.037)

        if(self.Radiobutton1['state']!='disabled'):
            self.Label3.place_forget()
            self.Label5.place_forget()
            self.Label6.place_forget()

            self.Spinbox2.place_forget()
            self.Spinbox2_1.place_forget()
            self.Spinbox2_2.place_forget()

        self.Button1.bind('<Button-1>',partial(self.hier,Canvas12=Canvas12))



    def hier(self,e,Canvas12):
        global ret1
        a.clear()
        points = ReadData_h('data.txt');
        points = CutToTwoFeatures(points,2,3);
        print(points)
        anmt_h=self.Spinbox1.get()
        global anima_time_h
        anima_time_h=float(anmt_h)

        hist=[]
        for i in range (0,len(points)):
            hist.append(i);

        ret1=[0]*len(points)
        outline='['
        i=0
        names={}

        for i in range(0,len(points)):
            names[str(points[i])]=i
        l=0
        last=[]
        while(len(points)>1):
            l=l+1
            matrix=list()
            print ('Distance matrix no. '+str(l)+': ')
            for i in range(0,len(points)):
                m=[0]*len(points)
                t=[0]*len(points)
                for j in range(0,len(points)):
                    t[j]=th.Thread(target=distance,args=(j,points[i],points[j],))
                    t[j].start()
                    #m[j]=distance(points[i],points[j])
                for j in range(0,len(points)):
                    t[j].join()
                    m[j]=ret1[j]
                    #print("ret1 = "+str(ret1))
                print (str(m))
                matrix.append(m)

            m=minimum(matrix)
            print("m = "+str(m))
            pts=list()
            p1=points[m[0]]
            p2=points[m[1]]

            print("p1 "+str(p1))
            print("p2 "+str(p2))
            pts.append(p1)
            pts.append(p2)

            points.remove(p1)
            points.remove(p2)
            midpoint=newpoint(pts)
            points.append(midpoint)
            c1=names.pop(str(p1))
            c2=names.pop(str(p2))

            print("c1 = "+str(c1))
            print("c2 = "+str(c2))

            d1=distance_p(p1,p2)
            last.append([(c1+c2)/2,d1])
            dd1=0
            dd2=0
            for ll in last:
                if(c1 == ll[0]):
                    dd1=ll[1]
            for ll in last:
                if(c2 == ll[0]):
                    dd2=ll[1]
            h1=[c1,c1]
            h2=[dd1,d1]
            h11=[c2,c2]
            h22=[dd2,d1]
            h111=[c1,c2]
            h222=[d1,d1]

            # plt.plot(h1, h2, linewidth=0.5,c="green",gid=1)
            # plt.pause(0.5)

            a.plot(h1, h2, linewidth=0.5,c="green",gid=1)
            Canvas12.draw()
            time.sleep(anima_time_h)

            # plt.plot(h11, h22, linewidth=0.5,c="red")
            # plt.pause(0.5)

            a.plot(h11, h22, linewidth=0.5,c="red",gid=1)
            Canvas12.draw()
            time.sleep(anima_time_h)

            # plt.plot(h111, h222, linewidth=0.5,c="blue",gid=1)
            # plt.pause(0.5)

            a.plot(h111, h222, linewidth=0.5,c="blue",gid=1)
            Canvas12.draw()
            time.sleep(anima_time_h)


            # names[str(midpoint)]="["+str(c1)+str(c2)+"]"
            names[str(midpoint)]=(c1+c2)/2
            outline=names[str(midpoint)]



if __name__ == '__main__':
    vp_start_gui()
